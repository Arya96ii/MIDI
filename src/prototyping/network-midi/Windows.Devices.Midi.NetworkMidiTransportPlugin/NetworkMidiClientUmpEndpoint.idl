// These are WinRT because that's closer to COM than what I started with
// To be plugins to the service, these will need to change to COM DLLs
// so they can be discovered and dynamically loaded. WinRT can't be
// loaded in the same way.

namespace Windows.Devices.Midi.NetworkMidiTransportPlugin
{
    [default_interface]
    runtimeclass NetworkMidiClientUmpEndpoint // : Windows.Devices.Midi.ServiceContracts.IMidiUmpEndpoint
    {
        NetworkMidiClientUmpEndpoint();

        // TODO: These need to be whatever buffer Gary has implemented
        // and they may be assigned in the constructor, not necessarily 
        // exposed in this way. This is prototype code only
        IVector<UInt32> IncomingMessages { get; };
        IVector<UInt32> OutgoingMessages { get; };

        // TBD: do we need to break these out into a description class like 
        // Windows.Devices.Enumeration does today?
        String Id { get; };
        IMapView<String, Object> Properties { get; };


        // Not members of the UmpEndpoint interface contract. Just specific to Network impl
        // used by the factory which creates these endpoints. Derived from the json properties
        Windows.Foundation.IAsyncAction Start(String hostName, String port, String midiEndpointName, String productInstanceId);

    }
}