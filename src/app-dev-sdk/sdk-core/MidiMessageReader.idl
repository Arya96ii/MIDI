// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License
// ============================================================================
// This is part of the Windows MIDI Services App SDK and should be used
// in your Windows application via an official binary distribution.
// Further information: https://github.com/microsoft/MIDI/
// ============================================================================

import "MidiUmpMessageTypeEnum.idl";
import "MidiUmpWithTimestamp.idl";

import "MidiUmpSizeEnum.idl";


// TODO: Consider thread synchronization for this class. Right now, assumes single-threaded access

namespace Microsoft.Devices.Midi2
{
    // WinRT doesn't let you return null values so we need to consider the
    // the circumstances where the caller didn't check for the end but
    // kept reading, or the caller is multi-threaded and another thread
    // drained the queue while they were looping
    enum MidiMessageReaderEndOfMessagesBehavior
    {
        ThrowException = 0,
        WaitAndBlockCallingThread
    };

    [default_interface]
    runtimeclass MidiMessageReader // not IClosable because this needs to keep the lifetime of the EndpointConnection
    {
        //MidiMessageReader();

        MidiMessageReaderEndOfMessagesBehavior EndOfMessagesBehavior{ get; set; };

        // EOF for MIDI messages.
        Boolean EndOfMessages{ get; };

        // look at the timestamp in the buffer. This is always the first 64 bits at the read pointer
        UInt64 PeekNextTimestamp();

        // look at the next message's type without moving the read pointer (skips over the timestamp to do this)
        MidiUmpMessageType PeekNextUmpMessageType();

        // copy the next message without moving the read pointer
        MidiUmpWithTimestamp PeekNextMessage();
        
        // copies all pending messages into a List
        IVector<MidiUmpWithTimestamp> ReadToEnd();

        // reads a single message in a polymorphic way
        MidiUmpWithTimestamp ReadNextMessage();


        // this tells you what kind of struct to read from the stream, if you are using the struct read functions
        MidiUmpSize PeekNextUmpSize();

        // these require you to know what the next message type is. You can
        // get that from the PeekNextUmpSize method. Keep in mind that these
        // messages also include a timestamp in each one so you get 
        // 32 + sizeof(timestamp) (currently 64 bits) back from ReadUmp32, 
        // for example.
        MidiUmp32 ReadUmp32();
        MidiUmp64 ReadUmp64();
        MidiUmp96 ReadUmp96();
        MidiUmp128 ReadUmp128();


        // a performance optimization. We'll see if this works well for performance-focused client apps before
        // going through the process of creating a completely separate classic COM interface with pointer access.
        // returns the number of bytes read into the buffer. Will always read whole messages.
        // 
        // If EndOfMessagesBehavior is set to block, this will block ONLY if there were no messages at all to read.
        // Otherwise, it will simply return whatever was read.
        UInt32 ReadTimestampedUmpStructsIntoBuffer(Windows.Foundation.IMemoryBufferReference buffer, UInt32 byteOffsetinBuffer, UInt32 maxBytesToRead);
    }
}