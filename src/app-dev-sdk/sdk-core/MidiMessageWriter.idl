// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License
// ============================================================================
// This is part of the Windows MIDI Services App SDK and should be used
// in your Windows application via an official binary distribution.
// Further information: https://github.com/microsoft/MIDI/
// ============================================================================


// TODO: Consider thread synchronization for this class. Right now, assumes single-threaded access

import "MidiUmpWithTimestamp.idl";
import "MidiUmpWithTimestampList.idl";


namespace Microsoft.Devices.Midi2
{
    enum MidiMessageWriterQueueFullBehavior
    {
        ThrowException = 0,
        WaitAndBlockCallingThread

        // May also have options to:
        // - Allocate a side-by-side buffer and table the messages until they can be sent
        // - Reallocate buffer size (this is very expensive, so not recommended)
        // Both of those options require real investigation before we consider them here.
    };

    [default_interface]
    runtimeclass MidiMessageWriter // not IClosable because this needs to keep the lifetime of the EndpointConnection
    {
        //MidiMessageWriter();

        Boolean IsFull { get; };

        void WriteUmpWords32(UInt64 midiTimestamp, UInt32 umpWord1);
        void WriteUmpWords64(UInt64 midiTimestamp, UInt32 umpWord1, UInt32 umpWord2);
        void WriteUmpWords96(UInt64 midiTimestamp, UInt32 umpWord1, UInt32 umpWord2, UInt32 umpWord3);
        void WriteUmpWords128(UInt64 midiTimestamp, UInt32 umpWord1, UInt32 umpWord2, UInt32 umpWord3, UInt32 umpWord4);

        void WriteUmpWords(UInt64 midiTimeStamp, UInt32[] words, UInt8 wordCount);

        void WriteUmpWithTimestamp(MidiUmpWithTimestamp ump);

        //void WriteMultipleUmpsWithTimestamps(IVector<UmpWithTimestamp> umpList);
        void WriteMultipleUmpsWithTimestamps(MidiUmpWithTimestampList umpList);

        // a performance optimization. We'll see if this works well for performance-focused client apps before
        // going through the process of creating a completely separate classic COM interface with pointer access.
        // returns the number of bytes written from the buffer.
        UInt32 WriteTimestampedUmpStructsFromBuffer(Windows.Foundation.IMemoryBufferReference buffer, UInt32 byteOffsetinBuffer, UInt32 maxBytesToWrite);

        void WriteTimestampedUmp32Struct(MidiUmp32 ump);
        void WriteTimestampedUmp64Struct(MidiUmp64 ump);
        void WriteTimestampedUmp96Struct(MidiUmp96 ump);
        void WriteTimestampedUmp128Struct(MidiUmp128 ump);


        // NOTE: This class doesn't use the usual buffered approach which requires a call to Flush().
        // May rethink that, but currently, there's no perf benefit to transmitting multiple
        // messages at once.
        // However, there does need to be a notification to the service that the message(s)
        // are ready to transmit. So this class will include a method like Complete() or 
        // Notify() or Signal() or similar. That breaks the usual stream pattern, but is
        // appropriate here.

    }
}