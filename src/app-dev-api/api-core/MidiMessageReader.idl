// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License
// ============================================================================
// This is part of the Windows MIDI Services App API and should be used
// in your Windows application via an official binary distribution.
// Further information: https://github.com/microsoft/MIDI/
// ============================================================================

import "IMidiUmp32.idl";
import "IMidiUmp64.idl";
import "IMidiUmp96.idl";
import "IMidiUmp128.idl";

import "MidiUmp32.idl";
import "MidiUmp64.idl";
import "MidiUmp96.idl";
import "MidiUmp128.idl";

import "MidiUmpSizeEnum.idl";
import "IMidiMessageClientFilter.idl";

// TODO: Consider thread synchronization for this class. Right now, assumes single-threaded access

namespace Windows.Devices.Midi2
{
    // WinRT doesn't let you return null values so we need to consider the
    // the circumstances where the caller didn't check for the end but
    // kept reading, or the caller is multi-threaded and another thread
    // drained the queue while they were looping
    enum MidiMessageReaderEndOfMessagesBehavior
    {
        ThrowException = 0,
        WaitAndBlockCallingThread
    };

    enum MidiMessageClientFilterStrategy
    {
        OrFilters = 0,      // any filters may pass to accept the message
        AndFilters,     // all attached filters must pass to accept the message
    };

    [default_interface]
    runtimeclass MidiMessageReader // not IClosable because this needs to keep the lifetime of the EndpointConnection
    {
        String Id{get; };

        // creates a reader with a GUID as the id
        MidiMessageReader();

        // apps may want to have a unique Id for a reader, like "Foo Controller Channel 7" or something
        MidiMessageReader(String uniqueId);



        MidiMessageReaderEndOfMessagesBehavior EndOfMessagesBehavior{ get; set; };

        // zero or more filters for this reader. This is the real reason to have multiple readers on an endpoint
        IVector<IMidiMessageClientFilter> Filters{ get; };

        MidiMessageClientFilterStrategy FilterStrategy{ get; set; };

        // EOF for MIDI messages.
        Boolean EndOfMessages{ get; };

        // look at the timestamp in the buffer. Where this is is set by the read pointer, and the ump header structure
        UInt64 PeekNextTimestamp();

        // this tells you what kind of struct to read from the stream, if you are using the struct read functions
        MidiUmpSize PeekNextUmpSize();

        // these require you to know what the next message type is. You can
        // get that from the PeekNextUmpSize method. Keep in mind that these
        // messages also include a header in each one so you get  the size of 
        // the header (which has 64 bit timestamp) + 32 bits back from ReadUmp32, 
        // for example.
        MidiUmp32 ReadUmp32();
        MidiUmp64 ReadUmp64();
        MidiUmp96 ReadUmp96();
        MidiUmp128 ReadUmp128();

        // If EndOfMessagesBehavior is set to block, this will block ONLY if there were no messages at all to read.
        // Otherwise, it will simply return whatever was read.
        UInt32 ReadBuffer(Windows.Foundation.IMemoryBufferReference buffer, UInt32 byteOffsetinBuffer, UInt32 maxBytesToRead);

    }
}